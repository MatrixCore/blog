[{"content":"After writing some code for MatrixCore, MatrixSQLiteStore and nio/matrixcore-sqlite, I decided I should start a blog.\nDeciding on a Database Rewriting the database code 1, 2, or 3 times I started the MatrixCore database code based on Apples Core Data framework. This did integrate nicely into SwiftUI as it provides a special viewContext, which is designed to be used for UI requests. But the class hierarchies CoreData uses is not that good suited to store chat messages. Also, many people did say that CoreData does not scale that well with many entries.\nThis got me to start using GRDB.swift which worked quite well, but had no viewContext. Therefore I created a NioAccountStore which holds a reference to all accounts, which also makes the creation of the MatrixCore client much easier, and so can hold a TaskHandle for the sync background task.\nAfter I decided to use GRDB.swift I started implementing the /sync task, starting with state events, so that the client has a general idea of known rooms to store messages under so it can show them.\nThis worked quite well, but after a short time I noticed that I did not sort my messages and that the SQLite rowid is not a stable identifier, and also I can\u0026rsquo;t insert older messages into the store, which is required for example for the bridge import feature. This got me to rethink my database layout again, and search for a way to store the messages in order, but still leave the option to insert messages at earlier times into the store.\nSwift\u0026rsquo;s Decoder protocol and GRDB The matrix protocol has quite an amount of different message and state events, and also is extensible, which makes designing the database to exactly hold that quite hard. My idea to go around this was to save the raw content json into the database for example as JSON or plist to save columns.\nThankfully GRDB has a feature built into the library that if an attribute of the struct is mapped to the table is Codable it will automatically be encoded into JSON and stored as text in the database.\nBut for the MatrixStateEventType protocol, which is used to store the State Events, Decodable can not be implemented, as for this the event type is required, which is not part of the content object, but part of the enclosing JSON. This type is also required to index the database, so I can search for an m.room.create Event to get the room metadata, without scanning all events in the room.\nThe way to implement this is to haveto have an init function with the arguments decoder and type, but the Decodable protocol only takes a Decoder. So a way to get the Decoder for the specific column is required. This is possible with the superDecoder(forKey:) function on the KeyedDecodingContainer, but GRDB does not update the CodingPath so that the resulting Decoder only has the elements already decoded by the decoder decoding the struct holding the content, and not the subkey/column. 1\n  GRDB.swift#1210\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"http://blog.matrixcore.dev/posts/dev-blog-01/","summary":"After writing some code for MatrixCore, MatrixSQLiteStore and nio/matrixcore-sqlite, I decided I should start a blog.\nDeciding on a Database Rewriting the database code 1, 2, or 3 times I started the MatrixCore database code based on Apples Core Data framework. This did integrate nicely into SwiftUI as it provides a special viewContext, which is designed to be used for UI requests. But the class hierarchies CoreData uses is not that good suited to store chat messages.","title":"Dev Blog 01"}]